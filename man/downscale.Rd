% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downscale.R
\name{downscale}
\alias{downscale}
\title{Downscaling of Land-Use (Change) Data}
\usage{
downscale(
  targets,
  start.areas,
  times = NULL,
  xmat = NULL,
  betas = NULL,
  areas.update.fun = areas.sum_to,
  xmat.coltypes = NULL,
  xmat.proj = NULL,
  xmat.dyn.fun = xmat.sum_to,
  priors = NULL,
  restrictions = NULL,
  options = downscale_control()
)
}
\arguments{
\item{targets}{A dataframe with mandatory columns: \code{times} (character), \code{lu.to} (character), and \code{value} (numeric, all values >= 0). Optional column: \code{lu.from} (character). Represents the downscaling targets for each time step and land-use change.}

\item{start.areas}{A dataframe with starting areas. Includes mandatory columns: \code{ns} (character, representing grid IDs for downscaling) and \code{value} (numeric, all areas >= 0 and sum of areas >= sum of targets). Optional column: \code{lu.from} (character).}

\item{times}{A character vector of time steps for downscaling. The first time step must be present in \code{targets}. If \code{NULL}, times are derived from unique values in \code{targets}. Default is \code{NULL}.}

\item{xmat}{A dataframe with explanatory variables for econometric priors. Includes columns: \code{ns} (character), \code{ks} (character), and \code{value} (numeric). If \code{NULL}, a placeholder is used. Default is \code{NULL}.}

\item{betas}{A dataframe of coefficients for econometric priors. Includes columns: \code{ks} (character), \code{lu.to} (character), and \code{value} (numeric). Optional column: \code{lu.from} (character). If \code{NULL}, a placeholder is used. Default is \code{NULL}.}

\item{areas.update.fun}{A function providing an update for dynamic xmat columns. Takes as arguments \code{res}, \code{curr.areas}, \code{priors}, \code{xmat.proj} and must return a dataframe with columns \code{ns}, \code{ks}, and \code{value}. Defaults to \code{areas.sum_to()}, which sums over \code{lu.to}.}

\item{xmat.coltypes}{A vector \code{ks}, with each element being either "static", "dynamic", or "projected". Determines how different columns in \code{xmat} are treated during the downscaling process.}

\item{xmat.proj}{A dataframe with projections. Includes columns: \code{times} (character), \code{ns} (character), \code{ks} (character), and \code{value} (numeric). Required for each \code{xmat.coltype} specified as projected.}

\item{xmat.dyn.fun}{A function providing updates for dynamic xmat columns. Takes as arguments \code{res}, \code{curr.areas}, \code{priors}, \code{xmat.proj} and must return a dataframe with \verb{ns x ks(dynamic)} columns.}

\item{priors}{A dataframe with exogenous priors. Includes columns: \code{times} (character, optional), \code{ns} (character), \code{lu.from} (character, optional), \code{lu.to} (character), and \code{value} (numeric, >= 0). An optional \code{weight} column (numeric, 0 <= weight <= 1) can be supplied to adjust the influence of exogenous priors.}

\item{restrictions}{A dataframe with restrictions. Includes columns: \code{ns} (character), \code{lu.from} (character, optional), \code{lu.to} (character), and \code{value} (numeric). Values must be either zero or one, indicating whether the MNL function should be set to zero for certain combinations.}

\item{options}{A list of solver options. Use \verb{\link{downscale_control}} to obtain default options and for more detailed information.}
}
\value{
A list containing three elements:
\itemize{
\item \code{out.res}: A dataframe with columns \code{times}, \code{ns}, \code{lu.from}, \code{lu.to}, and \code{value} (area allocation).
\item \code{out.solver}: A list detailing the solver output.
\item \code{ds.inputs}: A list documenting all the inputs used in the downscaling function.
}
}
\description{
Performs downscaling of land-use data over specified time steps using a range of inputs, including targets, areas, explanatory variables, and priors. It supports both bias correction and non-targeted downscaling methods.
}
\details{
The function integrates various data inputs to match \code{p} targets using either projections from an MNL-type model or exogenous priors. Appropriate input validation and preprocessing are performed before downscaling.
}
\examples{
require(dplyr)
require(tidyr)
require(tibble)
betas = NULL
for (jj in unique(argentina_luc$lu.from)) {
 Y = dplyr::filter(argentina_luc,lu.from == jj & Ts == 2000) \%>\%
   pivot_wider(names_from = lu.to)
 X = argentina_df$xmat \%>\% tidyr::pivot_wider(names_from = "ks") \%>\%
   dplyr::arrange(match(ns,Y$ns))
 Y = Y \%>\% dplyr::select(-c(lu.from,Ts,ns))
 X = X \%>\% dplyr::select(-c(ns))
 res1 <- mnlogit(as.matrix(X), as.matrix(Y),baseline = which(colnames(Y) == jj),
          niter = 3,nburn = 2)
 betas = betas \%>\% dplyr::bind_rows(
  apply(res1$postb, c(1, 2), mean) \%>\%
  as.data.frame() \%>\% tibble::rownames_to_column("ks") \%>\%
  pivot_longer(cols = -c(1),names_to = "lu.to") \%>\%
  dplyr::mutate(lu.from = jj,.before="lu.to")
 )
}
ns = unique(argentina_df$lu_levels$ns)
priors = data.frame(ns = as.character(ns),lu.from="Cropland",
            lu.to="Forest",value = as.numeric(runif(length(ns))))
res1 = downscale(targets = argentina_FABLE \%>\% dplyr::filter(times == "2010"),
         start.areas = argentina_df$lu_levels,
         xmat = argentina_df$xmat,
         betas = betas \%>\% dplyr::filter(lu.from!="Cropland" | lu.to!="Forest"),
         priors = priors)

 dgp1 = sim_luc(1000,tt = 3)
 res1 = downscale(targets = dgp1$targets,start.area = dgp1$start.areas,
        xmat = dgp1$xmat,betas = dgp1$betas,times = c(1:3))
}

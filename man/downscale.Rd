% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downscale.R
\name{downscale}
\alias{downscale}
\title{Downscaling of land-use (change) data}
\usage{
downscale(
  targets,
  start.areas,
  times = NULL,
  xmat = NULL,
  betas = NULL,
  areas.update.fun = areas.sum_to,
  xmat.coltypes = NULL,
  xmat.proj = NULL,
  xmat.dyn.fun = xmat.sum_to,
  priors = NULL,
  restrictions = NULL,
  options = downscale_control()
)
}
\arguments{
\item{targets}{A dataframe including the columns: times (character), lu.from (character, optional), lu.to (character) and value (numeric) (all targets >= 0)}

\item{start.areas}{A dataframe containing the starting areas with columns lu.from (character, optional), ns (character) and value (numeric), with ns being the IDs of the grid to downscale to and all areas >= 0 and with sum(areas) >= sum(targets).}

\item{times}{a character Vector of time steps for which downscaling is done. The first time-step has to be present in \code{targets}. Defaults to NULL, in which case the times are the unique time arguments in targets.}

\item{xmat}{A dataframe containing the explanatory variables for the econometric priors with columns ns (character), ks (character) and value (numeric). Defaults to NULL.
Either \code{xmat} and \code{betas} or \code{priors} have to be provided for each combination of
\code{lu.from} and \code{lu.to} in \code{targets}.}

\item{betas}{A dataframe of coefficients with columns ks (character), lu.from (character, optional), lu.to (character) and value (numeric). Defaults to NULL.
Either \code{xmat} and \code{betas} or \code{priors} have to be provided for each combination of
\code{lu.from} and \code{lu.to} in \code{targets}.}

\item{areas.update.fun}{function providing update for dynamic xmat columns, must take as arguments res, curr.areas, priors, xmat.proj, must return dataframe with columns ns, ks & value defaults to areas.sum_to() which sums over lu.to}

\item{xmat.coltypes}{ks vector, each can be either "static", "dynamic", or "projected"}

\item{xmat.proj}{dataframe with columns times (character), ns (character), ks (character), value (numeric) must be present for each xmat.coltype specified as projected}

\item{xmat.dyn.fun}{function providing update for dynamic xmat columns, must take as arguments res, curr.areas, priors, xmat.proj must return ns x ks(dynamic) columns}

\item{priors}{A dataframe with exogeneous priors containing the columns times (character, optional), ns (character), lu.from (character, optional), lu.to, (character) and value (numeric, with value >= 0); An optional
column \code{weight} (numeric, 0 <= weight <= 1) can be supplied. If both econometric and exogeneous priors are specified this value gives the weight of the exogeneous priors in the downscaling.}

\item{restrictions}{A dataframe with columns ns (character), lu.from (character, optional), lu.to (character) and value (numeric). Values must be either zero or one. If restrictions are one, the MNL function is set to zero.}

\item{options}{A list with solver options. Call \code{\link{downscale_control}} for default options and for more detail.}
}
\value{
A list containing
\itemize{
\item \code{out.res} Dataframe with columns times, ns, lu.from, lu.to & value (area allocation)
\item \code{out.solver} A list of the solver output
\item \code{ds.inputs} A list documenting all the downscale function inputs
}
}
\description{
Downscaling of land-use (change) data
}
\details{
Given \code{p} targets matches either the projections from an MNL-type model or exogenous priors.
}
\examples{
require(dplyr)
require(tidyr)
require(tibble)
betas = NULL
for (jj in unique(argentina_luc$lu.from)) {
 Y = dplyr::filter(argentina_luc,lu.from == jj & Ts == 2000) \%>\%
   pivot_wider(names_from = lu.to)
 X = argentina_df$xmat \%>\% tidyr::pivot_wider(names_from = "ks") \%>\%
   dplyr::arrange(match(ns,Y$ns))
 Y = Y \%>\% dplyr::select(-c(lu.from,Ts,ns))
 X = X \%>\% dplyr::select(-c(ns))
 res1 <- mnlogit(as.matrix(X), as.matrix(Y),baseline = which(colnames(Y) == jj),
          niter = 3,nburn = 2)
 betas = betas \%>\% dplyr::bind_rows(
  apply(res1$postb, c(1, 2), mean) \%>\%
  as.data.frame() \%>\% tibble::rownames_to_column("ks") \%>\%
  pivot_longer(cols = -c(1),names_to = "lu.to") \%>\%
  dplyr::mutate(lu.from = jj,.before="lu.to")
 )
}
ns = unique(argentina_df$lu_levels$ns)
priors = data.frame(ns = as.character(ns),lu.from="Cropland",
            lu.to="Forest",value = as.numeric(runif(length(ns))))
res1 = downscale(targets = argentina_FABLE \%>\% dplyr::filter(times == "2010"),
         start.areas = argentina_df$lu_levels,
         xmat = argentina_df$xmat,
         betas = betas \%>\% dplyr::filter(lu.from!="Cropland" | lu.to!="Forest"),
         priors = priors)

 dgp1 = sim_luc(1000,tt = 3)
 res1 = downscale(targets = dgp1$targets,start.area = dgp1$start.areas,
        xmat = dgp1$xmat,betas = dgp1$betas,times = c(1:3))
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downscale.R
\name{downscale}
\alias{downscale}
\title{Downscaling of land-use (change) data}
\usage{
downscale(
  targets,
  start.areas,
  times = NULL,
  xmat = NULL,
  betas = NULL,
  areas.update.fun = areas.sum_to,
  xmat.coltypes = NULL,
  xmat.proj = NULL,
  xmat.dyn.fun = xmat.sum_to,
  priors = NULL,
  restrictions = NULL,
  options = downscale_control()
)
}
\arguments{
\item{targets}{A dataframe with columns times, lu.from (optional), lu.to and value (all targets >= 0)}

\item{start.areas}{A dataframe of areas with columns lu.from (optional), ns and value, with all areas >= 0 and with sum(areas) >= sum(targets)}

\item{times}{Vector of time steps where downscaling is done. The first time step has to be present in \code{targets}. Defaults to NULL, in which case the times are the unique time values in targets.}

\item{xmat}{A dataframe of explanatory variables with columns ns, ks and value.   Defaults to NULL.
Either \code{xmat} and \code{betas} or \code{priors} have to be provided for each combination of
\code{lu.from} and \code{lu.to} in \code{targets}.}

\item{betas}{A dataframe of coefficients with columns ks, lu.from (optional), lu.to & value. Defaults to NULL.
Either \code{xmat} and \code{betas} or \code{priors} have to be provided for each combination of
\code{lu.from} and \code{lu.to} in \code{targets}.}

\item{areas.update.fun}{function providing update for dynamic xmat columns, must take as arguments res, curr.areas, priors, xmat.proj, must return dataframe with columns ns, ks & value defaults to areas.sum_to() which sums over lu.to}

\item{xmat.coltypes}{ks vector, each can be either "static", "dynamic", or "projected"}

\item{xmat.proj}{dataframe with columns times, ns, ks, must be present for each xmat.coltype specified as projected}

\item{xmat.dyn.fun}{function providing update for dynamic xmat columns, must take as arguments res, curr.areas, priors, xmat.proj must return ns x ks(dynamic) columns}

\item{priors}{A dataframe of priors with columns times (optional), ns, lu.from (optional), lu.to (with priors >= 0); An optional
column \code{weight} can be supplied. This has to be fully numeric with all values between
0 and 1. If both econometric and exogeneous priors are specified this value gives the weight of the exogeneous
priors in the downscaling.}

\item{restrictions}{A dataframe with columns ns, lu.from (optional), lu.to and value. Values must be zero or one. If restrictions are one, the MNL function is set to zero}

\item{options}{A list with solver options. Call \code{\link{downscale_control}} for default options and for more detail.}
}
\value{
A list containing
\itemize{
\item \code{out.res} Dataframe with columns times, ns, lu.from, lu.to & value (area allocation)
\item \code{out.solver} A list of the solver output
\item \code{ds.inputs} A list documenting all the downscale function inputs
}
}
\description{
Downscaling of land-use (change) data
}
\details{
Given \code{p} targets matches either the projections from an MNL-type model or exogenous priors.
}
\examples{
require(dplyr)
require(tidyr)
require(tibble)
betas = NULL
for (jj in unique(argentina_luc$lu.from)) {
 Y = dplyr::filter(argentina_luc,lu.from == jj & Ts == 2000) \%>\%
   pivot_wider(names_from = lu.to)
 X = argentina_df$xmat \%>\% tidyr::pivot_wider(names_from = "ks") \%>\%
   dplyr::arrange(match(ns,Y$ns))
 Y = Y \%>\% dplyr::select(-c(lu.from,Ts,ns))
 X = X \%>\% dplyr::select(-c(ns))
 res1 <- mnlogit(as.matrix(X), as.matrix(Y),baseline = which(colnames(Y) == jj),
          niter = 3,nburn = 2)
 betas = betas \%>\% dplyr::bind_rows(
  apply(res1$postb, c(1, 2), mean) \%>\%
  as.data.frame() \%>\% tibble::rownames_to_column("ks") \%>\%
  pivot_longer(cols = -c(1),names_to = "lu.to") \%>\%
  dplyr::mutate(lu.from = jj,.before="lu.to")
 )
}
ns = unique(argentina_df$lu_levels$ns)
priors = data.frame(ns = as.character(ns),lu.from="Cropland",
            lu.to="Forest",value = runif(length(ns)))
res1 = downscale(targets = argentina_FABLE \%>\% dplyr::filter(times == "2010"),
         start.areas = argentina_df$lu_levels,
         xmat = argentina_df$xmat,
         betas = betas \%>\% dplyr::filter(lu.from!="Cropland" | lu.to!="Forest"),
         priors = priors)

}
